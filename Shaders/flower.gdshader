shader_type spatial;
render_mode cull_disabled, specular_disabled;

// ğŸŒŸ ä¿®å¤1ï¼šGodot 4 çš„å…¨å±€å˜é‡ä¸èƒ½æ˜¯è´´å›¾ï¼æŠŠ wind_noise æ”¹å›æ™®é€šçš„ uniformã€‚
global uniform float wind_scale;
global uniform float wind_speed;
global uniform float wind_strength;
global uniform vec3 wind_direction;
uniform sampler2D wind_noise : filter_linear_mipmap; // â¬…ï¸ å¿…é¡»æ˜¯æ™®é€šçš„ uniform

uniform sampler2D flower_texture : source_color, filter_nearest;
uniform float flower_bendiness = 1.0;
uniform float sway_back : hint_range(0.0, 1.0, 0.01) = 1.0;
uniform float light_steps = 3.0;

varying vec3 node_pos_view;
varying vec3 node_pos_world;
varying vec4 world_pos;

vec4 CalculateWind(vec4 position, float speed, vec3 rotate_direction, float bend, float uv_scale, float mip_level){
	// é‡‡æ ·é£å™ªè´´å›¾
	vec3 noise_texture = textureLod(wind_noise, (position.xz * uv_scale) + (speed * -wind_direction.xz), mip_level).rgb;
	noise_texture = noise_texture * (1. + sway_back) - sway_back;

	// è®¡ç®—é¡¶ç‚¹åç§»
	vec4 displace = vec4((noise_texture * rotate_direction - noise_texture * noise_texture * vec3(0.0, 1.0, 0.0) * bend) , 0.0);
	return displace;
}

void vertex() {
	world_pos = MODEL_MATRIX * vec4(VERTEX, 1.0);
	node_pos_view = NODE_POSITION_VIEW;
	node_pos_world = NODE_POSITION_WORLD;

	float speed = TIME * wind_speed;
	float uv_scale = wind_scale;
	float wind_intensity = wind_strength * flower_bendiness;

	vec4 direction = inverse(MODEL_MATRIX) * vec4(wind_direction, 0.0);

	vec4 displace = CalculateWind(world_pos, speed, direction.xyz, flower_bendiness, uv_scale, 4.0);
	displace *= wind_intensity;

	VERTEX += displace.rgb;
}

void fragment() {
	vec4 color = texture(flower_texture, UV);

	ALBEDO = color.rgb;
	ALPHA = color.a;
	ALPHA_SCISSOR_THRESHOLD = 0.75;

	SPECULAR = 0.0;
	ROUGHNESS = 0.0; 
	// ğŸŒŸ ä¿®å¤2ï¼šåˆ é™¤äº† Godot 4 ä¸­éæ³•çš„ LIGHT_VERTEX èµ‹å€¼æ“ä½œï¼Œé˜²æ­¢å¼•æ“å´©æºƒã€‚
}

void light(){
	// å¡é€šé˜¶æ¢¯å…‰ç…§ (Cel Shading)
	float light = clamp(dot(NORMAL, LIGHT), 0.0, 1.0);
	light = round(light * light_steps) / light_steps;

	DIFFUSE_LIGHT += light * (LIGHT_COLOR / PI) * ATTENUATION;
}